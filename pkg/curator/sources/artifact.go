package sources

import (
	"context"
	"strings"
	"sync"
	"time"

	"github.com/zen-systems/flowgate/pkg/artifact"
)

// ArtifactSource searches the artifact store for relevant artifacts.
type ArtifactSource struct {
	mu        sync.RWMutex
	artifacts []*artifact.Artifact
	maxItems  int
}

// ArtifactOption configures an ArtifactSource.
type ArtifactOption func(*ArtifactSource)

// WithMaxArtifacts sets the maximum number of artifacts to store.
func WithMaxArtifacts(max int) ArtifactOption {
	return func(a *ArtifactSource) {
		a.maxItems = max
	}
}

// NewArtifactSource creates a new artifact source.
func NewArtifactSource(opts ...ArtifactOption) *ArtifactSource {
	a := &ArtifactSource{
		artifacts: make([]*artifact.Artifact, 0),
		maxItems:  500,
	}
	for _, opt := range opts {
		opt(a)
	}
	return a
}

// Name returns the source identifier.
func (a *ArtifactSource) Name() string {
	return "artifacts"
}

// Available always returns true for artifact source.
func (a *ArtifactSource) Available() bool {
	return true
}

// Query searches artifacts for relevant content.
func (a *ArtifactSource) Query(ctx context.Context, query string) ([]QueryResult, error) {
	a.mu.RLock()
	defer a.mu.RUnlock()

	queryLower := strings.ToLower(query)
	keywords := extractKeywords(queryLower)

	var results []QueryResult
	for _, art := range a.artifacts {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
		}

		// Search in content and prompt
		contentLower := strings.ToLower(art.Content)
		promptLower := strings.ToLower(art.Prompt)

		contentRelevance := calculateRelevance(contentLower, keywords)
		promptRelevance := calculateRelevance(promptLower, keywords)

		// Use the higher relevance, but weight content more
		relevance := contentRelevance*0.7 + promptRelevance*0.3

		if relevance > 0.1 {
			results = append(results, QueryResult{
				Content:    art.Content,
				Path:       "artifact:" + art.ID,
				Confidence: relevance,
				Timestamp:  art.CreatedAt,
				Metadata: map[string]string{
					"artifact_id": art.ID,
					"model":       art.Model,
					"adapter":     art.Adapter,
					"version":     itoa(int64(art.Version)),
					"prompt":      truncate(art.Prompt, 200),
				},
			})
		}
	}

	sortByConfidence(results)
	return results, nil
}

// Store adds an artifact to the source.
func (a *ArtifactSource) Store(art *artifact.Artifact) {
	if art == nil {
		return
	}

	a.mu.Lock()
	defer a.mu.Unlock()

	// Check if artifact already exists (update in place)
	for i, existing := range a.artifacts {
		if existing.ID == art.ID {
			a.artifacts[i] = art
			return
		}
	}

	a.artifacts = append(a.artifacts, art)

	// Trim if over capacity (remove oldest entries)
	if len(a.artifacts) > a.maxItems {
		a.artifacts = a.artifacts[len(a.artifacts)-a.maxItems:]
	}
}

// Get retrieves an artifact by ID.
func (a *ArtifactSource) Get(id string) *artifact.Artifact {
	a.mu.RLock()
	defer a.mu.RUnlock()

	for _, art := range a.artifacts {
		if art.ID == id {
			return art
		}
	}
	return nil
}

// GetByPrompt retrieves artifacts matching a prompt substring.
func (a *ArtifactSource) GetByPrompt(prompt string) []*artifact.Artifact {
	a.mu.RLock()
	defer a.mu.RUnlock()

	promptLower := strings.ToLower(prompt)
	var matches []*artifact.Artifact

	for _, art := range a.artifacts {
		if strings.Contains(strings.ToLower(art.Prompt), promptLower) {
			matches = append(matches, art)
		}
	}

	return matches
}

// GetRecent returns the n most recent artifacts.
func (a *ArtifactSource) GetRecent(n int) []*artifact.Artifact {
	a.mu.RLock()
	defer a.mu.RUnlock()

	if n > len(a.artifacts) {
		n = len(a.artifacts)
	}

	start := len(a.artifacts) - n
	result := make([]*artifact.Artifact, n)
	copy(result, a.artifacts[start:])
	return result
}

// Count returns the number of stored artifacts.
func (a *ArtifactSource) Count() int {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return len(a.artifacts)
}

// Clear removes all stored artifacts.
func (a *ArtifactSource) Clear() {
	a.mu.Lock()
	defer a.mu.Unlock()
	a.artifacts = make([]*artifact.Artifact, 0)
}

// GetByModel retrieves artifacts generated by a specific model.
func (a *ArtifactSource) GetByModel(model string) []*artifact.Artifact {
	a.mu.RLock()
	defer a.mu.RUnlock()

	var matches []*artifact.Artifact
	for _, art := range a.artifacts {
		if art.Model == model {
			matches = append(matches, art)
		}
	}
	return matches
}

// GetSince retrieves artifacts created after a specific time.
func (a *ArtifactSource) GetSince(t time.Time) []*artifact.Artifact {
	a.mu.RLock()
	defer a.mu.RUnlock()

	var matches []*artifact.Artifact
	for _, art := range a.artifacts {
		if art.CreatedAt.After(t) {
			matches = append(matches, art)
		}
	}
	return matches
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}
